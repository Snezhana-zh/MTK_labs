import string;
import lingo/pegcode/driver;

Expr ::= Int, Sub, Sum, Mul, Div, Var, MinusVar;
Int(value : int);
Sub(l : Expr, r : Expr);
Sum(l : Expr, r : Expr);
Div(l : Expr, r : Expr);
Mul(l : Expr, r : Expr);
Var(v : string);
MinusVar(e : Expr);

Rational : (a: int, b: int);

NOD(a : int, b : int) -> int {
    if (a > 0 && b > 0) {
        if (a != b) {
            if (a > b) {
                NOD(a - b, b);
            } else {
                NOD(a, b - a);
            }
        }
        else a;
    }
    else 1;
}

Valid(r : Rational) -> bool {
    r.b != 0;
}

shortenRational(r : Rational) -> Rational {
    nod = NOD(r.a, r.b);
    Rational(r.a / nod, r.b / nod);
}

checkVars(e: Expr, vars : [Pair<string, Rational>]) -> bool {
    switch(e) {
        Int(i): true;
        Var(v) : {
            index = either(findi(vars, \var -> if (var.first == v) true else false), -1);
            if (index != -1) {
                true;
            }
            else {
                false;
            }
        }
        Mul(e1, e2): checkVars(e1, vars) && checkVars(e2, vars);
        Sub(e1, e2): checkVars(e1, vars) && checkVars(e2, vars);
        Sum(e1, e2): checkVars(e1, vars) && checkVars(e2, vars);
        Div(e1, e2): checkVars(e1, vars) && checkVars(e2, vars);
        MinusVar(e1) : checkVars(e1, vars);
    }
}

mulRat(r1: Rational, r2: Rational) -> Rational {
    shortenRational(Rational(r1.a * r2.a, r1.b * r2.b));
}

divRat(r1: Rational, r2: Rational) -> Maybe<Rational> {
    r = shortenRational(Rational(r1.a * r2.b, r1.b * r2.a));
    if (Valid(r)) Some(r)
    else None();
}

subRat(r1: Rational, r2: Rational) -> Rational {
    shortenRational(Rational(r1.a * r2.b - r1.b * r2.a, r1.b * r2.b));
}

sumRat(r1: Rational, r2: Rational) -> Rational {
    shortenRational(Rational(r1.a * r2.b + r1.b * r2.a, r1.b * r2.b));
}

negRat(r1: Rational) -> Rational {
    Rational(-1 * r1.a, r1.b);
}

calcExpr(e: Expr, vars : [Pair<string, Rational>]) -> Maybe<Rational> {
    switch(e) {
        Int(i): Some(Rational(i, 1));
        Var(v) : {
            index = either(findi(vars, \var -> if (var.first == v) true else false), -1);
            if (index != -1 && Valid(vars[index].second)) Some(vars[index].second)
            else None();
        }
        Mul(e1, e2): {
            maybeMap2(mulRat)(calcExpr(e1, vars), calcExpr(e2, vars));
        }
        Sub(e1, e2): {
            maybeMap2(subRat)(calcExpr(e1, vars), calcExpr(e2, vars));
        }
        Sum(e1, e2): {
            maybeMap2(sumRat)(calcExpr(e1, vars), calcExpr(e2, vars));
        }
        Div(e1, e2): {
            maybeBind2(divRat)(calcExpr(e1, vars), calcExpr(e2, vars));
        }
        MinusVar(e1) : {
            maybeMap(calcExpr(e1, vars), negRat);
        }
    }
}

lingoGrammar = compilePegGrammar("#include labs/grammar7lab.lingo");

buildSub(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> Sub(acc, x));
}

buildDiv(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> Div(acc, x));
}

specialPegActions = {
	t = setTree(defaultPegActions.t, "buildDiv", buildDiv);
    res_t = setTree(t, "buildSub", buildSub);
	SemanticActions(res_t);
}

main() {
    vars : [Pair<string, Rational>] = [Pair("a", Rational(10, 1)), Pair("b", Rational(6, 1))];
    s : string = " 12 / 6 + (1 - 7) / 3 + ( a * 7 ) ";
    e = parsic(lingoGrammar, s, specialPegActions);
    if (checkVars(e, vars)) {
        val = calcExpr(e, vars);
        switch(calcExpr(e, vars)) {
            None() : println("ERROR DIV 0");
            Some(r) : println("result = " + i2s(r.a) + "/" + i2s(r.b));
        }
    }
    else {
        println("unknown vars");
    }
    
}
